{"paragraphs":[{"text":"%md\n## Welcome to LAGraph\nThis notebook provides an introduction to using the LAGraph package to program a linear algebra-based graph algorithm. It demonstrates the application of the two semirings described in the [LAGraph implementation of the Bellman-Ford algorithm](https://ibm.github.io/lagraph/algorithms-bellmanford.html). To demonstrate the linear algebra approach the tutorial is designed to be completed in two passes. On the first pass we will demonstrate the approach using a type that leads to a distance-only Bellman-Ford computation. On the second pass we will use a 3-Tuple type to perform a complete-path Bellman-Ford computation. Paragraphs marked with \"1st Pass\" should be executed on only the first pass. Paragraphs marked with \"2nd Pass\" should be executed on only the second pass. Paragraphs marked with \"Common\" should be execute on both passes.\n\nAfter completing the first pass and before starting the second pass, you should restart the spark interpreter, to do this:\n\n1. Select the notebook's \"Interpreter binding\" (gear icon upper right hand corner) to toggle / display the \"Interpreter binding\" display\n2. Select the recycle icon next to the Spark interpreter\n3. Select \"OK\" in response to \"Do you want to restart spark interpreter?\"\n4. Select the notebook's \"Interpreter binding\" (gear icon upper right hand corner) to toggle / hide the \"Interpreter binding\" display\n\nFor each pass, start by loading the LAGraph jar. Note that there are other ways to load the LAGraph jar, e.g., see the [zeppelin documentation](https://zeppelin.apache.org/docs/latest/interpreter/spark.html#2-loading-spark-properties), but for now we will load the artifact directly from the sonatype snapshot repository.\n\nThe following paragraph must be run before any other spark paragraphs. If you don't run it first you'll get the message \n\n```bash\nMust be used before SparkInterpreter (%spark) initialized\n```\n    \nIf this happens then use then restart the spark interpreter and try again.\n","user":"anonymous","dateUpdated":"2017-10-22T22:25:14-0400","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1508722481970_1910870765","id":"20170323-134354_2057993334","dateCreated":"2017-10-22T21:34:41-0400","dateStarted":"2017-10-22T22:25:14-0400","dateFinished":"2017-10-22T22:25:14-0400","status":"FINISHED","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:22204","results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h2>Welcome to LAGraph</h2>\n<p>This notebook provides an introduction to using the LAGraph package to program a linear algebra-based graph algorithm. It demonstrates the application of the two semirings described in the <a href=\"https://ibm.github.io/lagraph/algorithms-bellmanford.html\">LAGraph implementation of the Bellman-Ford algorithm</a>. To demonstrate the linear algebra approach the tutorial is designed to be completed in two passes. On the first pass we will demonstrate the approach using a type that leads to a distance-only Bellman-Ford computation. On the second pass we will use a 3-Tuple type to perform a complete-path Bellman-Ford computation. Paragraphs marked with &ldquo;1st Pass&rdquo; should be executed on only the first pass. Paragraphs marked with &ldquo;2nd Pass&rdquo; should be executed on only the second pass. Paragraphs marked with &ldquo;Common&rdquo; should be execute on both passes.</p>\n<p>After completing the first pass and before starting the second pass, you should restart the spark interpreter, to do this:</p>\n<ol>\n  <li>Select the notebook&rsquo;s &ldquo;Interpreter binding&rdquo; (gear icon upper right hand corner) to toggle / display the &ldquo;Interpreter binding&rdquo; display</li>\n  <li>Select the recycle icon next to the Spark interpreter</li>\n  <li>Select &ldquo;OK&rdquo; in response to &ldquo;Do you want to restart spark interpreter?&rdquo;</li>\n  <li>Select the notebook&rsquo;s &ldquo;Interpreter binding&rdquo; (gear icon upper right hand corner) to toggle / hide the &ldquo;Interpreter binding&rdquo; display</li>\n</ol>\n<p>For each pass, start by loading the LAGraph jar. Note that there are other ways to load the LAGraph jar, e.g., see the <a href=\"https://zeppelin.apache.org/docs/latest/interpreter/spark.html#2-loading-spark-properties\">zeppelin documentation</a>, but for now we will load the artifact directly from the sonatype snapshot repository.</p>\n<p>The following paragraph must be run before any other spark paragraphs. If you don&rsquo;t run it first you&rsquo;ll get the message </p>\n<pre><code class=\"bash\">Must be used before SparkInterpreter (%spark) initialized\n</code></pre>\n<p>If this happens then use then restart the spark interpreter and try again.</p>\n</div>"}]}},{"title":"Load the LAGraph jar: Common","text":"%spark.dep\n\n// Load the LAGraph artifact from the sonatype snapshot repository ...\nz.addRepo(\"sonatype-snapshots\").url(\"https://oss.sonatype.org/content/repositories/snapshots/\").snapshot()\nz.load(\"com.github.ibm:lagraph-core_2.11:0.1.0-SNAPSHOT\")","user":"anonymous","dateUpdated":"2017-10-22T22:22:44-0400","config":{"tableHide":false,"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"title":true,"results":{},"enabled":true,"editorHide":false},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1508722481971_1910486016","id":"20170323-103022_744615705","dateCreated":"2017-10-22T21:34:41-0400","dateStarted":"2017-10-22T22:22:44-0400","dateFinished":"2017-10-22T22:22:49-0400","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:22205"},{"text":"%md\nNow that we have access to the LAGraph jar let's perform some imports and define a couple of functions to facilitate printing semirings, execute the following paragraph on both passes.","user":"anonymous","dateUpdated":"2017-10-22T22:24:21-0400","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1508722481971_1910486016","id":"20170323-235248_1394570144","dateCreated":"2017-10-22T21:34:41-0400","dateStarted":"2017-10-22T22:24:21-0400","dateFinished":"2017-10-22T22:24:21-0400","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:22206","results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>Now that we have access to the LAGraph jar let&rsquo;s perform some imports and define a couple of functions to facilitate printing semirings, execute the following paragraph on both passes.</p>\n</div>"}]}},{"title":"Setup some utility functions: Common","text":"// some imports ...\nimport com.ibm.lagraph.{ LagContext, LagSemigroup, LagSemiring, LagVector }\n\n// for verbose printing\nimport scala.reflect.classTag\ndef float2Str(f: Float): String = {\n  if (f == LagSemigroup.infinity(classTag[Float])) \"   inf\"\n  else if (f == LagSemigroup.minfinity(classTag[Float])) \"   minf\"\n  else \"%6.3f\".format(f)\n}\ndef long2Str(l: Long): String = {\n  if (l == LagSemigroup.infinity(classTag[Long])) \" inf\"\n  else if (l == LagSemigroup.minfinity(classTag[Long])) \" minf\"\n  else \"%4d\".format(l)\n}\ndef BfType2Str(d: (Float, Long, Long)): String = {\n  val d1 = float2Str(d._1)\n  val d2 = long2Str(d._2)\n  val d3 = long2Str(d._3)\n  \"(%s,%s,%s)\".format(d1, d2, d3)\n}","user":"anonymous","dateUpdated":"2017-10-22T22:22:52-0400","config":{"tableHide":false,"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1508722481971_1910486016","id":"20170214-113431_1415670047","dateCreated":"2017-10-22T21:34:41-0400","dateStarted":"2017-10-22T22:22:52-0400","dateFinished":"2017-10-22T22:23:01-0400","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:22207"},{"text":"%md\nIn a Spark environment graphs will typically originate from an existing RDD. To illustrate the approach, lets define a super simple graph as an Indexed RDD and then use LAGraph to convert the RDD into an adjacency matrix. Here is the graph:\n\n![Graph/Matrix Duality](https://ibm.github.io/lagraph/img/tutorial/house-graph-directed.jpg \"house graph directed\")\n\nThe Spark specialization of `LagContext` provides the method `LagDstrContext.mFromRcvRdd` to convert a Spark RDD representation of the adjacency matrix into a `LagMatrix` representation. An alternate(non-distributed) approach would be to use the base context method `LagContext.mFromMap` to convert a Scala `Map` representation of an adjacency matrix into a `LagMatrix`\n\nExecute the following paragraph on both passes.\n","user":"anonymous","dateUpdated":"2017-10-22T22:24:28-0400","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1508722481972_1908562271","id":"20170323-235417_196494696","dateCreated":"2017-10-22T21:34:41-0400","dateStarted":"2017-10-22T22:24:28-0400","dateFinished":"2017-10-22T22:24:28-0400","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:22208","results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>In a Spark environment graphs will typically originate from an existing RDD. To illustrate the approach, lets define a super simple graph as an Indexed RDD and then use LAGraph to convert the RDD into an adjacency matrix. Here is the graph:</p>\n<p><img src=\"https://ibm.github.io/lagraph/img/tutorial/house-graph-directed.jpg\" alt=\"Graph/Matrix Duality\" title=\"house graph directed\" /></p>\n<p>The Spark specialization of <code>LagContext</code> provides the method <code>LagDstrContext.mFromRcvRdd</code> to convert a Spark RDD representation of the adjacency matrix into a <code>LagMatrix</code> representation. An alternate(non-distributed) approach would be to use the base context method <code>LagContext.mFromMap</code> to convert a Scala <code>Map</code> representation of an adjacency matrix into a <code>LagMatrix</code></p>\n<p>Execute the following paragraph on both passes.</p>\n</div>"}]}},{"title":"Create a Simple (directed) Graph from an RDD: Common","text":"// define graph\nval numv = 5L\nval houseEdges = List(((1L, 0L), 20.0F), ((2L, 0L), 10.0F), ((3L, 1L), 15.0F), ((3L, 2L), 30.0F), ((4L, 2L), 50.0F), ((4L, 3L), 5.0F))\nval rcvGraph = sc.parallelize(houseEdges)\n\n// obtain a distributed context for Spark environment\nval nblock = 1 // set parallelism (blocks on one axis)\nval hc = LagContext.getLagDstrContext(sc, numv, nblock)\n\nprintln(\"Input graph: >\\n%s<\".format(hc.mFromRcvRdd(rcvGraph, 0.0F).toString(float2Str)))","user":"anonymous","dateUpdated":"2017-10-22T22:23:06-0400","config":{"tableHide":false,"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1508722481973_1908177522","id":"20170214-111451_625371675","dateCreated":"2017-10-22T21:34:41-0400","dateStarted":"2017-10-22T22:23:06-0400","dateFinished":"2017-10-22T22:23:09-0400","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:22209"},{"text":"%md\nFollowing [LAGraph documentation for the Bellman-Ford algorithm](https://ibm.github.io/lagraph/algorithms-bellmanford.html), the remainder of this notebook has paragraphs of three types:\n\n1. Distance-only - paragraphs for the distance-only semiring\n2. Path-augmented - paragraphs for the path-augmented semiring\n3. Common - paragraphs for both (distance-only and path-augmented) semirings\n\nFor the remaining paragraphs, on the first pass run the \"Distance-only\" and \"Common\" paragraphs, i.e., skip \"Path-augmented\" paragraphs. On the second pass run both the \"Path-augmented\" and \"Common\" paragraphs","user":"anonymous","dateUpdated":"2017-10-22T22:24:34-0400","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1508722481974_1909331769","id":"20170323-142709_1872356798","dateCreated":"2017-10-22T21:34:41-0400","dateStarted":"2017-10-22T22:24:34-0400","dateFinished":"2017-10-22T22:24:34-0400","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:22210","results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>Following <a href=\"https://ibm.github.io/lagraph/algorithms-bellmanford.html\">LAGraph documentation for the Bellman-Ford algorithm</a>, the remainder of this notebook has paragraphs of three types:</p>\n<ol>\n  <li>Distance-only - paragraphs for the distance-only semiring</li>\n  <li>Path-augmented - paragraphs for the path-augmented semiring</li>\n  <li>Common - paragraphs for both (distance-only and path-augmented) semirings</li>\n</ol>\n<p>For the remaining paragraphs, on the first pass run the &ldquo;Distance-only&rdquo; and &ldquo;Common&rdquo; paragraphs, i.e., skip &ldquo;Path-augmented&rdquo; paragraphs. On the second pass run both the &ldquo;Path-augmented&rdquo; and &ldquo;Common&rdquo; paragraphs</p>\n</div>"}]}},{"text":"%md\nThe following paragraph contains code for the [mathematical forumation for the Distance-only semiring](https://ibm.github.io/lagraph/algorithms-bellmanford.html#implemention-of-the-distance-only-semiring), execute it only on the first pass.","user":"anonymous","dateUpdated":"2017-10-22T22:24:36-0400","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1508722481975_1908947020","id":"20170323-134833_422587344","dateCreated":"2017-10-22T21:34:41-0400","dateStarted":"2017-10-22T22:24:36-0400","dateFinished":"2017-10-22T22:24:36-0400","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:22211","results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>The following paragraph contains code for the <a href=\"https://ibm.github.io/lagraph/algorithms-bellmanford.html#implemention-of-the-distance-only-semiring\">mathematical forumation for the Distance-only semiring</a>, execute it only on the first pass.</p>\n</div>"}]}},{"title":"Bellman Ford: Distance-only Semiring: Initialization: 1st Pass","text":"// Define distance-only type and semirings\ntype BfType = Float\nval BfMinPlusSr = LagSemiring.min_plus[BfType]\n\n// for edge initialization (weight mapping)\nval eInit = (kv: ((Long, Long), Float)) => (kv._1, kv._2.toFloat) // edge (weight)\n\n// for print\nval d2Str = float2Str(_)","user":"anonymous","dateUpdated":"2017-10-22T22:21:37-0400","config":{"tableHide":false,"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"editorHide":false,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1508722481975_1908947020","id":"20170214-113152_177436087","dateCreated":"2017-10-22T21:34:41-0400","dateStarted":"2017-10-22T22:21:37-0400","dateFinished":"2017-10-22T22:21:37-0400","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:22212"},{"text":"%md\nThe following paragraph contains code for the [mathematical forumation for the Path-augmented semiring] (https://ibm.github.io/lagraph/algorithms-bellmanford.html#implementation-of-the-path-augmented-semiring), execute it on the second pass.","user":"anonymous","dateUpdated":"2017-10-22T22:24:41-0400","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1508722481976_1907023276","id":"20170324-102901_2080161158","dateCreated":"2017-10-22T21:34:41-0400","dateStarted":"2017-10-22T22:24:41-0400","dateFinished":"2017-10-22T22:24:41-0400","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:22213","results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>The following paragraph contains code for the <a href=\"https://ibm.github.io/lagraph/algorithms-bellmanford.html#implementation-of-the-path-augmented-semiring\">mathematical forumation for the Path-augmented semiring</a>, execute it on the second pass.</p>\n</div>"}]}},{"title":"Bellman Ford: Path-augmented Semiring: Initialization: 2nd Pass","text":"// Initialize path-augmented Bellman Ford\n\ntype BfType = Tuple3[Float, Long, Long]\nval FloatInf = LagSemigroup.infinity(classTag[Float])\nval LongInf = LagSemigroup.infinity(classTag[Long])\nval nodeNil: Long = -1L\n\n// Ordering for BfType\ntrait BfTypeOrdering extends Ordering[BfType] {\n  def compare(ui: BfType, vi: BfType): Int = {\n    val w1 = ui._1; val h1 = ui._2; val p1 = ui._3\n    val w2 = vi._1; val h2 = vi._2; val p2 = vi._3\n    if (w1 < w2) -1\n    else if ((w1 == w2) && (h1 < h2)) -1\n    else if ((w1 == w2) && (h1 == h2) && (p1 < p2)) -1\n    else 1\n  }\n}\n\n// Numeric for BfType\ntrait BfTypeAsNumeric extends com.ibm.lagraph.LagSemiringAsNumeric[BfType] with BfTypeOrdering {\n  def plus(ui: BfType, vi: BfType): BfType = {\n    def f(x: Float, y: Float): Float =\n      if (x == FloatInf || y == FloatInf) FloatInf\n      else x + y\n    def g(x: Long, y: Long): Long =\n      if (x == LongInf || y == LongInf) LongInf\n      else x + y\n\n    val _zero = fromInt(0)\n    val w1 = ui._1; val h1 = ui._2; val p1 = ui._3\n    val w2 = vi._1; val h2 = vi._2; val p2 = vi._3\n    if (p2 != _zero._3)\n      if (p1 == _zero._3) (f(w1, w2), g(h1, h2), p2)\n      else if (p2 != nodeNil) (f(w1, w2), g(h1, h2), p2)\n      else (f(w1, w2), g(h1, h2), p1) // original\n    else (f(w1, w2), g(h1, h2), p1)\n  }\n  def times(x: BfType, y: BfType): BfType = min(x, y)\n  def fromInt(x: Int): BfType = x match {\n    case 0     => ((0.0).toFloat, 0L, nodeNil)\n    case 1     => (FloatInf, LongInf, LongInf)\n    case other => throw new RuntimeException(\"fromInt for: >%d< not implemented\".format(other))\n  }\n}\n\nimplicit object BfTypeAsNumeric extends BfTypeAsNumeric\nval BfMinPlusSr = LagSemiring.min_plus[BfType](Tuple3(FloatInf, LongInf, LongInf))\n\n// for edge initialization (weight mapping)\nval eInit = (kv: ((Long, Long), Float)) => (kv._1, (kv._2.toFloat, 1L, kv._1._2)) // edge (weight)\n\n// for print\nval d2Str = BfType2Str(_)","user":"anonymous","dateUpdated":"2017-10-22T22:23:19-0400","config":{"tableHide":false,"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"editorHide":false,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1508722481977_1906638527","id":"20170214-133445_954595033","dateCreated":"2017-10-22T21:34:41-0400","dateStarted":"2017-10-22T22:23:19-0400","dateFinished":"2017-10-22T22:23:20-0400","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:22214"},{"text":"%md\nThe following paragraph contains code for the initialization of both the distance-only and path-augmented implementations, execute it on both passes.","user":"anonymous","dateUpdated":"2017-10-22T22:24:46-0400","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1508722481977_1906638527","id":"20170324-103627_2948015","dateCreated":"2017-10-22T21:34:41-0400","dateStarted":"2017-10-22T22:24:46-0400","dateFinished":"2017-10-22T22:24:46-0400","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:22215","results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>The following paragraph contains code for the initialization of both the distance-only and path-augmented implementations, execute it on both passes.</p>\n</div>"}]}},{"title":"BellmanFord: Initialize: Common","text":"// initialize adjacency matrix\n// strip diagonal and add back in as BfMinPlusSr.one, use weight to derive BfType for edge\nval diagStripped = rcvGraph.flatMap { kv => if (kv._1._1 == kv._1._2) None else Some(eInit(kv)) }\nval rcvAdj = diagStripped.union(sc.range(0L, numv, 1L, rcvGraph.getNumPartitions).map { i => ((i, i), BfMinPlusSr.one) })\n\n// use distributed context-specific utility to convert from RDD to LagMatrix\nval mAdj = hc.mFromRcvRdd(rcvAdj, BfMinPlusSr.zero)\n\nprintln(\"mAdj: >\\n%s<\".format(mAdj.toString(d2Str)))\n\n// initialize vector d w/ source (input)\nval source = 0L\ndef dInit(di: BfType, ui: Long): BfType = if (ui == source) BfMinPlusSr.one else di\nval d_prev = hc.vReplicate(BfMinPlusSr.zero).zipWithIndex(dInit, Option(BfMinPlusSr.zero))\nprintln(\"d_initial: >\\n%s<\".format(d_prev.toString(d2Str)))","user":"anonymous","dateUpdated":"2017-10-22T22:23:25-0400","config":{"tableHide":false,"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"editorHide":false,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1508722481978_1907792774","id":"20170215-123604_1076247936","dateCreated":"2017-10-22T21:34:41-0400","dateStarted":"2017-10-22T22:23:25-0400","dateFinished":"2017-10-22T22:23:27-0400","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:22216"},{"text":"%md\nThe following paragraph contains code for the iterative part of both the distance-only and path-augmented implementations, execute it on both passes.","user":"anonymous","dateUpdated":"2017-10-22T22:24:51-0400","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1508722481978_1907792774","id":"20170324-125737_1979089053","dateCreated":"2017-10-22T21:34:41-0400","dateStarted":"2017-10-22T22:24:51-0400","dateFinished":"2017-10-22T22:24:51-0400","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:22217","results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>The following paragraph contains code for the iterative part of both the distance-only and path-augmented implementations, execute it on both passes.</p>\n</div>"}]}},{"title":"BellmanFord: Iterate: Common","text":"// iterate, relaxing edges\nval maxiter = d_prev.size\ndef bfIterate(k: Long, d_prev: LagVector[BfType]): LagVector[BfType] =\n  if (k == maxiter) d_prev else bfIterate(k + 1, mAdj.tV(BfMinPlusSr, d_prev))\n\nval d_final = bfIterate(0L, d_prev)\n\n// are we at a fixed point?\nif (d_final.equiv(mAdj.tV(BfMinPlusSr,d_final))) {\n  println(\"d_final: >\\n%s<\".format(d_final.toString(d2Str)))\n} else {\n  println(\"A negative-weight cycle exists.\")\n}","user":"anonymous","dateUpdated":"2017-10-22T22:23:33-0400","config":{"tableHide":false,"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1508722481978_1907792774","id":"20170214-131755_1202090570","dateCreated":"2017-10-22T21:34:41-0400","dateStarted":"2017-10-22T22:23:33-0400","dateFinished":"2017-10-22T22:23:34-0400","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:22218"},{"text":"","dateUpdated":"2017-10-22T21:34:41-0400","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"editorSetting":{"language":"scala"}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1508722481979_1907408025","id":"20170614-225925_586633064","dateCreated":"2017-10-22T21:34:41-0400","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:22219"}],"name":"lagraph-tutorial","id":"2CW1FHNAT","angularObjects":{"2CXWK56QU:shared_process":[],"2CWCAH9MB:shared_process":[],"2CXRT9CB5:shared_process":[],"2CVCSZ5JM:shared_process":[],"2CYCJ8EKK:shared_process":[],"2CWP6NKRX:shared_process":[],"2CX5HE7GA:shared_process":[],"2CWNHX4HQ:shared_process":[],"2CVNC6ZPT:shared_process":[],"2CXSCP79T:shared_process":[],"2CY6YXM5S:shared_process":[],"2CY9555G2:shared_process":[],"2CY5EWRTS:shared_process":[],"2CVEAEKRN:shared_process":[],"2CX5ZCMAM:shared_process":[],"2CWNU525F:shared_process":[],"2CYMR1PAS:shared_process":[],"2CXPT26Z2:shared_process":[],"2CVNGMRB4:shared_process":[]},"config":{"looknfeel":"default","personalizedMode":"false"},"info":{}}