{"paragraphs":[{"text":"%md\n## Welcome to LAGraph.\nThis notebook provides an introduction to using the LAGraph package to program a linear algebra-based graph algorithm. It demonstrates the application of the two semirings described in the [LAGraph implementation of the Bellman-Ford algorithm](https://pages.github.ibm.com/hornwp/lagraph/algorithms-bellmanford.html). To demonstrate the linear algebra approach the tutorial is designed to be completed in two passes. On the first pass we will demonstrate the approach using a type that leads to a distance-only Bellman-Ford computation. On the second pass we will use a 3-Tuple type to perform a complete-path Bellman-Ford computation. Paragraphs marked with \"1st Pass\" should be executed on only the first pass. Paragraphs marked with \"2nd Pass\" should be executed on only the second pass. Paragraphs marked with \"Common\" should be execute on both passes.\n\nAfter completing the first pass and before starting the second pass, you should restart the spark interpreter, to do this:\n\n1. Select the notebook's \"Interpreter binding\" (gear icon upper right hand corner) to toggle / display the \"Interpreter binding\" display\n2. Select the recycle icon next to the Spark interpreter\n3. Select \"OK\" in response to \"Do you want to restart spark interpreter?\"\n4. Select the notebook's \"Interpreter binding\" (gear icon upper right hand corner) to toggle / hide the \"Interpreter binding\" display\n\nStart by loading the LAGraph jar. In the paragraph below, __modify the path__ in the following paragraph to reflect the location of the LAGraph jar file and then run the paragraph. Note that there are better ways to load the LAGraph jar, e.g., see the [zeppelin documentation for the '--jars' option](https://zeppelin.apache.org/docs/latest/interpreter/spark.html#2-loading-spark-properties).\n\nThe following paragraph must be run before any other spark paragraphs. If you don't run it first you'll get the message \n\n```bash\nMust be used before SparkInterpreter (%spark) initialized\n```\n    \nIf this happens then use then restart the spark interpreter and try again.\n","user":"anonymous","dateUpdated":"2017-07-17T11:14:43-0400","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1497472883102_715755717","id":"20170323-134354_2057993334","dateCreated":"2017-06-14T16:41:23-0400","dateStarted":"2017-07-17T11:14:43-0400","dateFinished":"2017-07-17T11:14:44-0400","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:8921"},{"title":"Load the LAGraph jar: Common","text":"%spark.dep\n\n// Assuming you didn't use one of the more clever ways to load the the LAGraph jar ...\n// fix the path to reflect the location of the downloaded LAGraph jar ...\nz.load(\"/home/ME/zeppelin-0.7.1-bin-all/lagraph_2.11-0.1.0-SNAPSHOT.jar\") // e.g., linux\n// z.load(\"/Users/ME/lagraph_2.11-0.1.0-SNAPSHOT.jar\") // e.g., mac-os","user":"anonymous","dateUpdated":"2017-07-17T11:45:53-0400","config":{"tableHide":true,"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1497472883118_697287770","id":"20170323-103022_744615705","dateCreated":"2017-06-14T16:41:23-0400","dateStarted":"2017-07-17T11:45:53-0400","dateFinished":"2017-07-17T11:45:57-0400","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:8922"},{"text":"%md\nNow that we have access to the LAGraph jar let's perform some imports and define a couple of functions to facilitate printing semirings.","user":"anonymous","dateUpdated":"2017-07-17T11:47:32-0400","config":{"tableHide":false,"editorSetting":{"language":"text","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/text","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1497472883120_707291241","id":"20170323-235248_1394570144","dateCreated":"2017-06-14T16:41:23-0400","dateStarted":"2017-07-17T11:47:32-0400","dateFinished":"2017-07-17T11:47:32-0400","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:8923","results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>Now that we have access to the LAGraph jar let&rsquo;s perform some imports and define a couple of functions to facilitate printing semirings.</p>\n</div>"}]}},{"title":"Setup some utility functions: Common","text":"// some imports ...\nimport com.ibm.lagraph.{ LagContext, LagSemigroup, LagSemiring, LagVector }\n\n// for verbose printing\nimport scala.reflect.classTag\ndef float2Str(f: Float): String = {\n  if (f == LagSemigroup.infinity(classTag[Float])) \"   inf\"\n  else if (f == LagSemigroup.minfinity(classTag[Float])) \"   minf\"\n  else \"%6.3f\".format(f)\n}\ndef long2Str(l: Long): String = {\n  if (l == LagSemigroup.infinity(classTag[Long])) \" inf\"\n  else if (l == LagSemigroup.minfinity(classTag[Long])) \" minf\"\n  else \"%4d\".format(l)\n}\ndef PathType2Str(d: (Float, Long, Long)): String = {\n  val d1 = float2Str(d._1)\n  val d2 = long2Str(d._2)\n  val d3 = long2Str(d._3)\n  \"(%s,%s,%s)\".format(d1, d2, d3)\n}","user":"anonymous","dateUpdated":"2017-07-17T11:46:01-0400","config":{"tableHide":false,"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1497472883122_708060739","id":"20170214-113431_1415670047","dateCreated":"2017-06-14T16:41:23-0400","dateStarted":"2017-07-17T11:46:01-0400","dateFinished":"2017-07-17T11:46:09-0400","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:8924"},{"text":"%md\nIn a Spark environment graphs will typically originate from an existing RDD. To illustrate the approach, lets define a super simple graph as an Indexed RDD and then use LAGraph to convert the RDD into an adjacency matrix. Here is the graph:\n\n![Graph/Matrix Duality](http://pokgsa.ibm.com/projects/s/spp/public/lagraph/house-graph-directed.jpg \"house graph directed\")\n\nThe Spark specialization of `LagContext` provides the method `LagDstrContext.mFromRcvRdd` to convert a Spark RDD representation of the adjacency matrix into a `LagMatrix` representation. An alternate(non-distributed) approach would be to use the base context method `LagContext.mFromMap` to convert a Scala `Map` representation of an adjacency matrix into a `LagMatrix`\n","user":"anonymous","dateUpdated":"2017-07-17T11:47:36-0400","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1497472883124_705752246","id":"20170323-235417_196494696","dateCreated":"2017-06-14T16:41:23-0400","dateStarted":"2017-07-17T11:47:36-0400","dateFinished":"2017-07-17T11:47:36-0400","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:8925","results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>In a Spark environment graphs will typically originate from an existing RDD. To illustrate the approach, lets define a super simple graph as an Indexed RDD and then use LAGraph to convert the RDD into an adjacency matrix. Here is the graph:</p>\n<p><img src=\"http://pokgsa.ibm.com/projects/s/spp/public/lagraph/house-graph-directed.jpg\" alt=\"Graph/Matrix Duality\" title=\"house graph directed\" /></p>\n<p>The Spark specialization of <code>LagContext</code> provides the method <code>LagDstrContext.mFromRcvRdd</code> to convert a Spark RDD representation of the adjacency matrix into a <code>LagMatrix</code> representation. An alternate(non-distributed) approach would be to use the base context method <code>LagContext.mFromMap</code> to convert a Scala <code>Map</code> representation of an adjacency matrix into a <code>LagMatrix</code></p>\n</div>"}]}},{"title":"Create a Simple (directed) Graph from an RDD: Common","text":"// define graph\nval numv = 5L\nval houseEdges = List(((1L, 0L), 20.0F), ((2L, 0L), 10.0F), ((3L, 1L), 15.0F), ((3L, 2L), 30.0F), ((4L, 2L), 50.0F), ((4L, 3L), 5.0F))\nval rcvGraph = sc.parallelize(houseEdges)\n\n// obtain a distributed context for Spark environment\nval nblock = 1 // set parallelism (blocks on one axis)\nval hc = LagContext.getLagDstrContext(sc, numv, nblock)\n\nprintln(\"Input graph: >\\n%s<\".format(hc.mFromRcvRdd(rcvGraph, 0.0F).toString(float2Str)))","user":"anonymous","dateUpdated":"2017-07-17T11:46:13-0400","config":{"tableHide":false,"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1497472883125_705367497","id":"20170214-111451_625371675","dateCreated":"2017-06-14T16:41:23-0400","dateStarted":"2017-07-17T11:46:13-0400","dateFinished":"2017-07-17T11:46:15-0400","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:8926"},{"text":"%md\nFollowing [LAGraph documentation for the Bellman-Ford algorithm](https://pages.github.ibm.com/hornwp/lagraph/algorithms-bellmanford.html), the remainder of this notebook has paragraphs of three types:\n\n1. Distance-only - paragraphs for the distance-only semiring\n2. Path-augmented - paragraphs for the path-augmented semiring\n3. Common - paragraphs for both (distance-only and path-augmented) semirings\n\nTo compare the two semirings, starting from here, first run the \"Distance-only\" and \"Common\" paragraphs, i.e., skip \"Path-augmented\" paragraphs. Then return\nto this point and run both the \"Path-augmented\" and \"Common\" paragraphs","user":"anonymous","dateUpdated":"2017-07-17T11:47:40-0400","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1497472883128_704213250","id":"20170323-142709_1872356798","dateCreated":"2017-06-14T16:41:23-0400","dateStarted":"2017-07-17T11:47:40-0400","dateFinished":"2017-07-17T11:47:40-0400","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:8927","results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>Following <a href=\"https://pages.github.ibm.com/hornwp/lagraph/algorithms-bellmanford.html\">LAGraph documentation for the Bellman-Ford algorithm</a>, the remainder of this notebook has paragraphs of three types:</p>\n<ol>\n  <li>Distance-only - paragraphs for the distance-only semiring</li>\n  <li>Path-augmented - paragraphs for the path-augmented semiring</li>\n  <li>Common - paragraphs for both (distance-only and path-augmented) semirings</li>\n</ol>\n<p>To compare the two semirings, starting from here, first run the &ldquo;Distance-only&rdquo; and &ldquo;Common&rdquo; paragraphs, i.e., skip &ldquo;Path-augmented&rdquo; paragraphs. Then return<br/>to this point and run both the &ldquo;Path-augmented&rdquo; and &ldquo;Common&rdquo; paragraphs</p>\n</div>"}]}},{"text":"%md\nThe following paragraph contains code for the [implemention of the distance-only semiring] (https://pages.github.ibm.com/hornwp/lagraph/algorithms-bellmanford.html#implemention-of-the-distance-only-semiring), execute it only on the first pass.","user":"anonymous","dateUpdated":"2017-07-17T11:47:42-0400","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1497472883130_704982748","id":"20170323-134833_422587344","dateCreated":"2017-06-14T16:41:23-0400","dateStarted":"2017-07-17T11:47:42-0400","dateFinished":"2017-07-17T11:47:42-0400","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:8928","results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>The following paragraph contains code for the <a href=\"https://pages.github.ibm.com/hornwp/lagraph/algorithms-bellmanford.html#implemention-of-the-distance-only-semiring\">implemention of the distance-only semiring</a>, execute it only on the first pass.</p>\n</div>"}]}},{"title":"Bellman Ford: Distance-only Semiring: Initialization: 1st Pass","text":"// Define distance-only type and semirings\ntype PathType = Float\nval PathMinPlusSr = LagSemiring.min_plus[PathType]\n\n// for edge initialization (weight mapping)\nval eInit = (kv: ((Long, Long), Float)) => (kv._1, kv._2.toFloat) // edge (weight)\n\n// for print\nval d2Str = float2Str(_)","user":"anonymous","dateUpdated":"2017-07-17T11:45:02-0400","config":{"tableHide":false,"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"editorHide":false,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1497472883131_704597999","id":"20170214-113152_177436087","dateCreated":"2017-06-14T16:41:23-0400","dateStarted":"2017-07-17T11:45:02-0400","dateFinished":"2017-07-17T11:45:03-0400","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:8929"},{"text":"%md\nThe following paragraph contains code for the [implementation of the path-augmented semiring] (https://pages.github.ibm.com/hornwp/lagraph/algorithms-bellmanford.html#implementation-of-the-path-augmented-semiring), execute it on the second pass.","user":"anonymous","dateUpdated":"2017-07-17T11:47:45-0400","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1497472883133_702289506","id":"20170324-102901_2080161158","dateCreated":"2017-06-14T16:41:23-0400","dateStarted":"2017-07-17T11:47:45-0400","dateFinished":"2017-07-17T11:47:45-0400","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:8930","results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>The following paragraph contains code for the <a href=\"https://pages.github.ibm.com/hornwp/lagraph/algorithms-bellmanford.html#implementation-of-the-path-augmented-semiring\">implementation of the path-augmented semiring</a>, execute it on the second pass.</p>\n</div>"}]}},{"title":"Bellman Ford: Path-augmented Semiring: Initialization: 2nd Pass","text":"// Initialize path-augmented Bellman Ford\n\ntype PathType = Tuple3[Float, Long, Long]\nval FloatInf = LagSemigroup.infinity(classTag[Float])\nval LongInf = LagSemigroup.infinity(classTag[Long])\nval nodeNil: Long = -1L\n\n// Ordering for PathType\ntrait PathTypeOrdering extends Ordering[PathType] {\n  def compare(ui: PathType, vi: PathType): Int = {\n    val w1 = ui._1; val h1 = ui._2; val p1 = ui._3\n    val w2 = vi._1; val h2 = vi._2; val p2 = vi._3\n    if (w1 < w2) -1\n    else if ((w1 == w2) && (h1 < h2)) -1\n    else if ((w1 == w2) && (h1 == h2) && (p1 < p2)) -1\n    else 1\n  }\n}\n\n// Numeric for PathType\ntrait PathTypeAsNumeric extends com.ibm.lagraph.LagSemiringAsNumeric[PathType] with PathTypeOrdering {\n  def plus(ui: PathType, vi: PathType): PathType = {\n    def f(x: Float, y: Float): Float =\n      if (x == FloatInf || y == FloatInf) FloatInf\n      else x + y\n    def g(x: Long, y: Long): Long =\n      if (x == LongInf || y == LongInf) LongInf\n      else x + y\n\n    val _zero = fromInt(0)\n    val w1 = ui._1; val h1 = ui._2; val p1 = ui._3\n    val w2 = vi._1; val h2 = vi._2; val p2 = vi._3\n    if (p2 != _zero._3)\n      if (p1 == _zero._3) (f(w1, w2), g(h1, h2), p2)\n      else if (p2 != nodeNil) (f(w1, w2), g(h1, h2), p2)\n      else (f(w1, w2), g(h1, h2), p1) // original\n    else (f(w1, w2), g(h1, h2), p1)\n  }\n  def times(x: PathType, y: PathType): PathType = min(x, y)\n  def fromInt(x: Int): PathType = x match {\n    case 0     => ((0.0).toFloat, 0L, nodeNil)\n    case 1     => (FloatInf, LongInf, LongInf)\n    case other => throw new RuntimeException(\"fromInt for: >%d< not implemented\".format(other))\n  }\n}\n\nimplicit object PathTypeAsNumeric extends PathTypeAsNumeric\nval PathMinPlusSr = LagSemiring.min_plus[PathType](Tuple3(FloatInf, LongInf, LongInf))\n\n// for edge initialization (weight mapping)\nval eInit = (kv: ((Long, Long), Float)) => (kv._1, (kv._2.toFloat, 1L, kv._1._2)) // edge (weight)\n\n// for print\nval d2Str = PathType2Str(_)","user":"anonymous","dateUpdated":"2017-07-17T11:46:19-0400","config":{"tableHide":false,"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"editorHide":false,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1497472883134_703443752","id":"20170214-133445_954595033","dateCreated":"2017-06-14T16:41:23-0400","dateStarted":"2017-07-17T11:46:19-0400","dateFinished":"2017-07-17T11:46:20-0400","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:8931"},{"text":"%md\nThe following paragraph contains code for the initialization part of both [the distance-only and path-augmented implementations] (https://pages.github.ibm.com/hornwp/lagraph/algorithms-bellmanford.html#implementation-of-the-distance-only-algorithmim), execute it on both passes.","user":"anonymous","dateUpdated":"2017-07-17T11:47:48-0400","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1497472883136_688823294","id":"20170324-103627_2948015","dateCreated":"2017-06-14T16:41:23-0400","dateStarted":"2017-07-17T11:47:48-0400","dateFinished":"2017-07-17T11:47:48-0400","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:8932","results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>The following paragraph contains code for the initialization part of both <a href=\"https://pages.github.ibm.com/hornwp/lagraph/algorithms-bellmanford.html#implementation-of-the-distance-only-algorithmim\">the distance-only and path-augmented implementations</a>, execute it on both passes.</p>\n</div>"}]}},{"title":"BellmanFord: Initialize: Common","text":"// initialize adjacency matrix\n// strip diagonal and add back in as PathMinPlusSr.one, use weight to derive PathType for edge\nval diagStripped = rcvGraph.flatMap { kv => if (kv._1._1 == kv._1._2) None else Some(eInit(kv)) }\nval rcvAdj = diagStripped.union(sc.range(0L, numv, 1L, rcvGraph.getNumPartitions).map { i => ((i, i), PathMinPlusSr.one) })\n\n// use distributed context-specific utility to convert from RDD to LagMatrix\nval mAdj = hc.mFromRcvRdd(rcvAdj, PathMinPlusSr.zero)\n\nprintln(\"mAdj: >\\n%s<\".format(mAdj.toString(d2Str)))\n\n// initialize vector d w/ source (input)\nval source = 0L\ndef dInit(di: PathType, ui: Long): PathType = if (ui == source) PathMinPlusSr.one else di\nval d_prev = hc.vReplicate(PathMinPlusSr.zero).zipWithIndex(dInit, Option(PathMinPlusSr.zero))\nprintln(\"d_initial: >\\n%s<\".format(d_prev.toString(d2Str)))","user":"anonymous","dateUpdated":"2017-07-17T11:46:35-0400","config":{"tableHide":false,"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"editorHide":false,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1497472883137_688438545","id":"20170215-123604_1076247936","dateCreated":"2017-06-14T16:41:23-0400","dateStarted":"2017-07-17T11:46:35-0400","dateFinished":"2017-07-17T11:46:37-0400","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:8933"},{"text":"%md\nThe following paragraph contains code for the iterative part of both [the distance-only and path-augmented implementations] (https://pages.github.ibm.com/hornwp/lagraph/algorithms-bellmanford.html#implementation-of-the-distance-only-algorithmim), execute it on both passes.","user":"anonymous","dateUpdated":"2017-07-17T11:47:51-0400","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1497472883140_687284298","id":"20170324-125737_1979089053","dateCreated":"2017-06-14T16:41:23-0400","dateStarted":"2017-07-17T11:47:51-0400","dateFinished":"2017-07-17T11:47:51-0400","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:8934","results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>The following paragraph contains code for the iterative part of both <a href=\"https://pages.github.ibm.com/hornwp/lagraph/algorithms-bellmanford.html#implementation-of-the-distance-only-algorithmim\">the distance-only and path-augmented implementations</a>, execute it on both passes.</p>\n</div>"}]}},{"title":"BellmanFord: Iterate: Common","text":"// iterate, relaxing edges\nval maxiter = d_prev.size\ndef iterate(k: Long, d_prev: LagVector[PathType]): LagVector[PathType] =\n  if (k == maxiter) d_prev else iterate(k + 1, mAdj.tV(PathMinPlusSr, d_prev))\n\nval d_final = iterate(0L, d_prev)\n\n// are we at a fixed point?\nif (d_final.equiv(mAdj.tV(PathMinPlusSr,d_final))) {\n  println(\"d_final: >\\n%s<\".format(d_final.toString(d2Str)))\n} else {\n  println(\"A negative-weight cycle exists.\")\n}","user":"anonymous","dateUpdated":"2017-07-17T11:46:40-0400","config":{"tableHide":false,"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1497472883142_688053796","id":"20170214-131755_1202090570","dateCreated":"2017-06-14T16:41:23-0400","dateStarted":"2017-07-17T11:46:40-0400","dateFinished":"2017-07-17T11:46:41-0400","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:8935"},{"text":"","user":"anonymous","dateUpdated":"2017-06-19T11:08:24-0400","config":{"colWidth":12,"enabled":true,"results":{},"editorSetting":{"language":"scala"},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1497495565639_900112931","id":"20170614-225925_586633064","dateCreated":"2017-06-14T22:59:25-0400","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:8936"}],"name":"lagraph-tutorial","id":"2CK4TZVMC","angularObjects":{"2CFCA5SHK:shared_process":[],"2CFN5TCMN:shared_process":[],"2CGAX79HM:shared_process":[],"2CHAG8PC8:shared_process":[],"2CDX6AA38:shared_process":[],"2CHG7D8AT:shared_process":[],"2CH5R7P5A:shared_process":[],"2CEN8XRQ1:shared_process":[],"2CHP929AC:shared_process":[],"2CDTB6J1G:shared_process":[],"2CG9ECQNN:shared_process":[],"2CHQYPY9A:shared_process":[],"2CHN4MV43:shared_process":[],"2CH88WF47:shared_process":[],"2CFGCEJ5C:shared_process":[],"2CGFPFBWU:shared_process":[],"2CGZ63XC9:shared_process":[],"2CFS2QZF2:shared_process":[],"2CGHGVAY6:shared_process":[]},"config":{"looknfeel":"default","personalizedMode":"false"},"info":{},"checkpoint":{"message":"July Release"}}